"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/shaders/shaders.ts":
/*!**************************************!*\
  !*** ./src/utils/shaders/shaders.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fragmentShader: function() { return /* binding */ fragmentShader; },\n/* harmony export */   vertexShader: function() { return /* binding */ vertexShader; }\n/* harmony export */ });\nconst vertexShader = \"\\nuniform float time;\\nuniform vec3 uColor[5];\\nvarying vec3 vColor;\\nvarying vec2 vUv;\\nvarying vec3 vPosition;\\nuniform vec4 resolution;\\nfloat PI = 3.141592653589793238;\\n\\n// Simplex 3D Noise (keep the original noise functions)\\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\\nfloat snoise(vec3 v){ \\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0);\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n  // First corner\\n  vec3 i  = floor(v + dot(v, C.yyy));\\n  vec3 x0 =   v - i + dot(i, C.xxx);\\n\\n  // Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min(g.xyz, l.zxy);\\n  vec3 i2 = max(g.xyz, l.zxy);\\n\\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\\n\\n  // Permutations\\n  i = mod(i, 490.0); \\n  vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));\\n\\n  // Gradients\\n  float n_ = 1.0/7.0;\\n  vec3 ns = n_ * D.wyz - D.xzx;\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_);\\n  vec4 x = x_ * ns.x + ns.yyyy;\\n  vec4 y = y_ * ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n  vec4 b0 = vec4(x.xy, y.xy);\\n  vec4 b1 = vec4(x.zw, y.zw);\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n  // Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n  // Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\\n}\\n\\nvoid main() {\\n  vec2 noiseCoord = uv*vec2(3.,4.);\\n  float tilt = -0.8*uv.y;\\n  float incline = uv.x*0.1;\\n  float offset = incline*mix(-.25,0.25,uv.y);\\n  \\n  float noise = snoise(vec3(noiseCoord.x + time*3., noiseCoord.y, time * 10.));\\n  noise = max(0.,noise);\\n  \\n  vec3 pos = vec3(\\n    position.x,\\n    position.y,\\n    position.z + noise * 0.3 + tilt + incline + offset\\n  );\\n\\n  vColor = uColor[4];\\n  \\n  for(int i = 0; i < 4; i++) {\\n    float noiseFlow = 5. + float(i)*0.3;\\n    float noiseSpeed = 10. + float(i)*0.3;\\n    float noiseSeed = 1. + float(i)*10.;\\n    vec2 noiseFreq = vec2(1.,1.4)*.4;\\n    float noiseFloor = 0.1;\\n    float noiseCeil = 0.6 + float(i)*0.07;\\n    \\n    float noise = smoothstep(\\n      noiseFloor,\\n      noiseCeil,\\n      snoise(vec3(\\n        noiseCoord.x*noiseFreq.x + time*noiseFlow,\\n        noiseCoord.y*noiseFreq.y, \\n        time * noiseSpeed + noiseSeed\\n      ))\\n    );\\n    \\n    vColor = mix(vColor, uColor[i], noise);\\n  }\\n\\n  vUv = uv;\\n  vPosition = position;\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\\n}\\n\";\nconst fragmentShader = \"\\nuniform float time;\\nuniform float progress;\\nuniform sampler2D texture1;\\nuniform vec4 resolution;\\nvarying vec2 vUv;\\nvarying vec3 vPosition;\\nvarying vec3 vColor;\\nfloat PI = 3.141592653589793238;\\n\\nvoid main() {\\n  // vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);\\n  gl_FragColor = vec4(vColor, 1.);\\n}\\n\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9zaGFkZXJzL3NoYWRlcnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxNQUFNQSxlQUFnQix1bEdBOEc1QjtBQUVNLE1BQU1DLGlCQUFrQixzVUFjOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL3NoYWRlcnMvc2hhZGVycy50cz83MTliIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSBgXG51bmlmb3JtIGZsb2F0IHRpbWU7XG51bmlmb3JtIHZlYzMgdUNvbG9yWzVdO1xudmFyeWluZyB2ZWMzIHZDb2xvcjtcbnZhcnlpbmcgdmVjMiB2VXY7XG52YXJ5aW5nIHZlYzMgdlBvc2l0aW9uO1xudW5pZm9ybSB2ZWM0IHJlc29sdXRpb247XG5mbG9hdCBQSSA9IDMuMTQxNTkyNjUzNTg5NzkzMjM4O1xuXG4vLyBTaW1wbGV4IDNEIE5vaXNlIChrZWVwIHRoZSBvcmlnaW5hbCBub2lzZSBmdW5jdGlvbnMpXG52ZWM0IHBlcm11dGUodmVjNCB4KXtyZXR1cm4gbW9kKCgoeCozNC4wKSsxLjApKngsIDI4OS4wKTt9XG52ZWM0IHRheWxvckludlNxcnQodmVjNCByKXtyZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO31cbmZsb2F0IHNub2lzZSh2ZWMzIHYpeyBcbiAgY29uc3QgdmVjMiAgQyA9IHZlYzIoMS4wLzYuMCwgMS4wLzMuMCk7XG4gIGNvbnN0IHZlYzQgIEQgPSB2ZWM0KDAuMCwgMC41LCAxLjAsIDIuMCk7XG5cbiAgLy8gRmlyc3QgY29ybmVyXG4gIHZlYzMgaSAgPSBmbG9vcih2ICsgZG90KHYsIEMueXl5KSk7XG4gIHZlYzMgeDAgPSAgIHYgLSBpICsgZG90KGksIEMueHh4KTtcblxuICAvLyBPdGhlciBjb3JuZXJzXG4gIHZlYzMgZyA9IHN0ZXAoeDAueXp4LCB4MC54eXopO1xuICB2ZWMzIGwgPSAxLjAgLSBnO1xuICB2ZWMzIGkxID0gbWluKGcueHl6LCBsLnp4eSk7XG4gIHZlYzMgaTIgPSBtYXgoZy54eXosIGwuenh5KTtcblxuICB2ZWMzIHgxID0geDAgLSBpMSArIDEuMCAqIEMueHh4O1xuICB2ZWMzIHgyID0geDAgLSBpMiArIDIuMCAqIEMueHh4O1xuICB2ZWMzIHgzID0geDAgLSAxLiArIDMuMCAqIEMueHh4O1xuXG4gIC8vIFBlcm11dGF0aW9uc1xuICBpID0gbW9kKGksIDQ5MC4wKTsgXG4gIHZlYzQgcCA9IHBlcm11dGUocGVybXV0ZShwZXJtdXRlKGkueiArIHZlYzQoMC4wLCBpMS56LCBpMi56LCAxLjApKSArIGkueSArIHZlYzQoMC4wLCBpMS55LCBpMi55LCAxLjApKSArIGkueCArIHZlYzQoMC4wLCBpMS54LCBpMi54LCAxLjApKTtcblxuICAvLyBHcmFkaWVudHNcbiAgZmxvYXQgbl8gPSAxLjAvNy4wO1xuICB2ZWMzIG5zID0gbl8gKiBELnd5eiAtIEQueHp4O1xuICB2ZWM0IGogPSBwIC0gNDkuMCAqIGZsb29yKHAgKiBucy56ICogbnMueik7XG4gIHZlYzQgeF8gPSBmbG9vcihqICogbnMueik7XG4gIHZlYzQgeV8gPSBmbG9vcihqIC0gNy4wICogeF8pO1xuICB2ZWM0IHggPSB4XyAqIG5zLnggKyBucy55eXl5O1xuICB2ZWM0IHkgPSB5XyAqIG5zLnggKyBucy55eXl5O1xuICB2ZWM0IGggPSAxLjAgLSBhYnMoeCkgLSBhYnMoeSk7XG4gIHZlYzQgYjAgPSB2ZWM0KHgueHksIHkueHkpO1xuICB2ZWM0IGIxID0gdmVjNCh4Lnp3LCB5Lnp3KTtcbiAgdmVjNCBzMCA9IGZsb29yKGIwKSoyLjAgKyAxLjA7XG4gIHZlYzQgczEgPSBmbG9vcihiMSkqMi4wICsgMS4wO1xuICB2ZWM0IHNoID0gLXN0ZXAoaCwgdmVjNCgwLjApKTtcbiAgdmVjNCBhMCA9IGIwLnh6eXcgKyBzMC54enl3KnNoLnh4eXk7XG4gIHZlYzQgYTEgPSBiMS54enl3ICsgczEueHp5dypzaC56end3O1xuICB2ZWMzIHAwID0gdmVjMyhhMC54eSxoLngpO1xuICB2ZWMzIHAxID0gdmVjMyhhMC56dyxoLnkpO1xuICB2ZWMzIHAyID0gdmVjMyhhMS54eSxoLnopO1xuICB2ZWMzIHAzID0gdmVjMyhhMS56dyxoLncpO1xuXG4gIC8vIE5vcm1hbGlzZSBncmFkaWVudHNcbiAgdmVjNCBub3JtID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChwMCxwMCksIGRvdChwMSxwMSksIGRvdChwMiwgcDIpLCBkb3QocDMscDMpKSk7XG4gIHAwICo9IG5vcm0ueDtcbiAgcDEgKj0gbm9ybS55O1xuICBwMiAqPSBub3JtLno7XG4gIHAzICo9IG5vcm0udztcblxuICAvLyBNaXggZmluYWwgbm9pc2UgdmFsdWVcbiAgdmVjNCBtID0gbWF4KDAuNiAtIHZlYzQoZG90KHgwLHgwKSwgZG90KHgxLHgxKSwgZG90KHgyLHgyKSwgZG90KHgzLHgzKSksIDAuMCk7XG4gIG0gPSBtICogbTtcbiAgcmV0dXJuIDQyLjAgKiBkb3QobSptLCB2ZWM0KGRvdChwMCx4MCksIGRvdChwMSx4MSksIGRvdChwMix4MiksIGRvdChwMyx4MykpKTtcbn1cblxudm9pZCBtYWluKCkge1xuICB2ZWMyIG5vaXNlQ29vcmQgPSB1dip2ZWMyKDMuLDQuKTtcbiAgZmxvYXQgdGlsdCA9IC0wLjgqdXYueTtcbiAgZmxvYXQgaW5jbGluZSA9IHV2LngqMC4xO1xuICBmbG9hdCBvZmZzZXQgPSBpbmNsaW5lKm1peCgtLjI1LDAuMjUsdXYueSk7XG4gIFxuICBmbG9hdCBub2lzZSA9IHNub2lzZSh2ZWMzKG5vaXNlQ29vcmQueCArIHRpbWUqMy4sIG5vaXNlQ29vcmQueSwgdGltZSAqIDEwLikpO1xuICBub2lzZSA9IG1heCgwLixub2lzZSk7XG4gIFxuICB2ZWMzIHBvcyA9IHZlYzMoXG4gICAgcG9zaXRpb24ueCxcbiAgICBwb3NpdGlvbi55LFxuICAgIHBvc2l0aW9uLnogKyBub2lzZSAqIDAuMyArIHRpbHQgKyBpbmNsaW5lICsgb2Zmc2V0XG4gICk7XG5cbiAgdkNvbG9yID0gdUNvbG9yWzRdO1xuICBcbiAgZm9yKGludCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGZsb2F0IG5vaXNlRmxvdyA9IDUuICsgZmxvYXQoaSkqMC4zO1xuICAgIGZsb2F0IG5vaXNlU3BlZWQgPSAxMC4gKyBmbG9hdChpKSowLjM7XG4gICAgZmxvYXQgbm9pc2VTZWVkID0gMS4gKyBmbG9hdChpKSoxMC47XG4gICAgdmVjMiBub2lzZUZyZXEgPSB2ZWMyKDEuLDEuNCkqLjQ7XG4gICAgZmxvYXQgbm9pc2VGbG9vciA9IDAuMTtcbiAgICBmbG9hdCBub2lzZUNlaWwgPSAwLjYgKyBmbG9hdChpKSowLjA3O1xuICAgIFxuICAgIGZsb2F0IG5vaXNlID0gc21vb3Roc3RlcChcbiAgICAgIG5vaXNlRmxvb3IsXG4gICAgICBub2lzZUNlaWwsXG4gICAgICBzbm9pc2UodmVjMyhcbiAgICAgICAgbm9pc2VDb29yZC54Km5vaXNlRnJlcS54ICsgdGltZSpub2lzZUZsb3csXG4gICAgICAgIG5vaXNlQ29vcmQueSpub2lzZUZyZXEueSwgXG4gICAgICAgIHRpbWUgKiBub2lzZVNwZWVkICsgbm9pc2VTZWVkXG4gICAgICApKVxuICAgICk7XG4gICAgXG4gICAgdkNvbG9yID0gbWl4KHZDb2xvciwgdUNvbG9yW2ldLCBub2lzZSk7XG4gIH1cblxuICB2VXYgPSB1djtcbiAgdlBvc2l0aW9uID0gcG9zaXRpb247XG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zLCAxLjApO1xufVxuYFxuXG5leHBvcnQgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBgXG51bmlmb3JtIGZsb2F0IHRpbWU7XG51bmlmb3JtIGZsb2F0IHByb2dyZXNzO1xudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTE7XG51bmlmb3JtIHZlYzQgcmVzb2x1dGlvbjtcbnZhcnlpbmcgdmVjMiB2VXY7XG52YXJ5aW5nIHZlYzMgdlBvc2l0aW9uO1xudmFyeWluZyB2ZWMzIHZDb2xvcjtcbmZsb2F0IFBJID0gMy4xNDE1OTI2NTM1ODk3OTMyMzg7XG5cbnZvaWQgbWFpbigpIHtcbiAgLy8gdmVjMiBuZXdVViA9ICh2VXYgLSB2ZWMyKDAuNSkpKnJlc29sdXRpb24uencgKyB2ZWMyKDAuNSk7XG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQodkNvbG9yLCAxLik7XG59XG5gIl0sIm5hbWVzIjpbInZlcnRleFNoYWRlciIsImZyYWdtZW50U2hhZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/shaders/shaders.ts\n"));

/***/ })

});