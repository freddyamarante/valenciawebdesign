"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/shaders/shaders.ts":
/*!**************************************!*\
  !*** ./src/utils/shaders/shaders.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fragmentShader: function() { return /* binding */ fragmentShader; },\n/* harmony export */   vertexShader: function() { return /* binding */ vertexShader; }\n/* harmony export */ });\nconst vertexShader = \"\\nuniform float time;\\nuniform vec3 uColor[5];\\nvarying vec3 vColor;\\nvarying vec2 vUv;\\nvarying vec3 vPosition;\\nuniform vec4 resolution;\\nfloat PI = 3.141592653589793238;\\n\\n// Simplex 3D Noise (keep the original noise functions)\\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\\nfloat snoise(vec3 v){ \\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0);\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n  // First corner\\n  vec3 i  = floor(v + dot(v, C.yyy));\\n  vec3 x0 =   v - i + dot(i, C.xxx);\\n\\n  // Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min(g.xyz, l.zxy);\\n  vec3 i2 = max(g.xyz, l.zxy);\\n\\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\\n\\n  // Permutations\\n  i = mod(i, 289.0); \\n  vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));\\n\\n  // Gradients\\n  float n_ = 1.0/7.0;\\n  vec3 ns = n_ * D.wyz - D.xzx;\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_);\\n  vec4 x = x_ * ns.x + ns.yyyy;\\n  vec4 y = y_ * ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n  vec4 b0 = vec4(x.xy, y.xy);\\n  vec4 b1 = vec4(x.zw, y.zw);\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n  // Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n  // Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\\n}\\n\\nvoid main() {\\n  vec2 noiseCoord = uv * vec2(6., 8.); // Increased frequency\\n  float tilt = -1.2 * uv.y; // Increased tilt\\n  float incline = uv.x * 0.2; // Increased incline\\n  float offset = incline * mix(-0.5, 0.5, uv.y); // Increased offset\\n  \\n  float noise = snoise(vec3(noiseCoord.x + time * 6., noiseCoord.y, time * 20.)); // Increased noise speed\\n  noise = max(0., noise);\\n  \\n  vec3 pos = vec3(\\n    position.x,\\n    position.y,\\n    position.z + noise * 0.6 + tilt + incline + offset // Increased noise impact\\n  );\\n\\n  vColor = uColor[4];\\n  \\n  for(int i = 0; i < 4; i++) {\\n    float noiseFlow = 10. + float(i) * 0.6; // Increased noise flow\\n    float noiseSpeed = 20. + float(i) * 0.6; // Increased noise speed\\n    float noiseSeed = 2. + float(i) * 20.0; // Increased noise seed\\n    vec2 noiseFreq = vec2(2., 2.8) * 0.2; // Increased noise frequency\\n    float noiseFloor = 0.2; // Adjusted noise floor\\n    float noiseCeil = 0.8 + float(i) * 0.14; // Increased noise ceiling\\n    \\n    float noise = smoothstep(\\n      noiseFloor,\\n      noiseCeil,\\n      snoise(vec3(\\n        noiseCoord.x * noiseFreq.x + time * noiseFlow,\\n        noiseCoord.y * noiseFreq.y, \\n        time * noiseSpeed + noiseSeed\\n      ))\\n    );\\n    \\n    vColor = mix(vColor, uColor[i], noise);\\n  }\\n\\n  vUv = uv;\\n  vPosition = position;\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\\n}\\n\";\nconst fragmentShader = \"\\nuniform float time;\\nuniform float progress;\\nuniform sampler2D texture1;\\nuniform vec4 resolution;\\nvarying vec2 vUv;\\nvarying vec3 vPosition;\\nvarying vec3 vColor;\\nfloat PI = 3.141592653589793238;\\n\\nvoid main() {\\n  // vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);\\n  gl_FragColor = vec4(vColor, 1.);\\n}\\n\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9zaGFkZXJzL3NoYWRlcnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxNQUFNQSxlQUFnQixzNUdBOEc1QjtBQUVNLE1BQU1DLGlCQUFrQixzVUFjOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL3NoYWRlcnMvc2hhZGVycy50cz83MTliIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSBgXG51bmlmb3JtIGZsb2F0IHRpbWU7XG51bmlmb3JtIHZlYzMgdUNvbG9yWzVdO1xudmFyeWluZyB2ZWMzIHZDb2xvcjtcbnZhcnlpbmcgdmVjMiB2VXY7XG52YXJ5aW5nIHZlYzMgdlBvc2l0aW9uO1xudW5pZm9ybSB2ZWM0IHJlc29sdXRpb247XG5mbG9hdCBQSSA9IDMuMTQxNTkyNjUzNTg5NzkzMjM4O1xuXG4vLyBTaW1wbGV4IDNEIE5vaXNlIChrZWVwIHRoZSBvcmlnaW5hbCBub2lzZSBmdW5jdGlvbnMpXG52ZWM0IHBlcm11dGUodmVjNCB4KXtyZXR1cm4gbW9kKCgoeCozNC4wKSsxLjApKngsIDI4OS4wKTt9XG52ZWM0IHRheWxvckludlNxcnQodmVjNCByKXtyZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO31cbmZsb2F0IHNub2lzZSh2ZWMzIHYpeyBcbiAgY29uc3QgdmVjMiAgQyA9IHZlYzIoMS4wLzYuMCwgMS4wLzMuMCk7XG4gIGNvbnN0IHZlYzQgIEQgPSB2ZWM0KDAuMCwgMC41LCAxLjAsIDIuMCk7XG5cbiAgLy8gRmlyc3QgY29ybmVyXG4gIHZlYzMgaSAgPSBmbG9vcih2ICsgZG90KHYsIEMueXl5KSk7XG4gIHZlYzMgeDAgPSAgIHYgLSBpICsgZG90KGksIEMueHh4KTtcblxuICAvLyBPdGhlciBjb3JuZXJzXG4gIHZlYzMgZyA9IHN0ZXAoeDAueXp4LCB4MC54eXopO1xuICB2ZWMzIGwgPSAxLjAgLSBnO1xuICB2ZWMzIGkxID0gbWluKGcueHl6LCBsLnp4eSk7XG4gIHZlYzMgaTIgPSBtYXgoZy54eXosIGwuenh5KTtcblxuICB2ZWMzIHgxID0geDAgLSBpMSArIDEuMCAqIEMueHh4O1xuICB2ZWMzIHgyID0geDAgLSBpMiArIDIuMCAqIEMueHh4O1xuICB2ZWMzIHgzID0geDAgLSAxLiArIDMuMCAqIEMueHh4O1xuXG4gIC8vIFBlcm11dGF0aW9uc1xuICBpID0gbW9kKGksIDI4OS4wKTsgXG4gIHZlYzQgcCA9IHBlcm11dGUocGVybXV0ZShwZXJtdXRlKGkueiArIHZlYzQoMC4wLCBpMS56LCBpMi56LCAxLjApKSArIGkueSArIHZlYzQoMC4wLCBpMS55LCBpMi55LCAxLjApKSArIGkueCArIHZlYzQoMC4wLCBpMS54LCBpMi54LCAxLjApKTtcblxuICAvLyBHcmFkaWVudHNcbiAgZmxvYXQgbl8gPSAxLjAvNy4wO1xuICB2ZWMzIG5zID0gbl8gKiBELnd5eiAtIEQueHp4O1xuICB2ZWM0IGogPSBwIC0gNDkuMCAqIGZsb29yKHAgKiBucy56ICogbnMueik7XG4gIHZlYzQgeF8gPSBmbG9vcihqICogbnMueik7XG4gIHZlYzQgeV8gPSBmbG9vcihqIC0gNy4wICogeF8pO1xuICB2ZWM0IHggPSB4XyAqIG5zLnggKyBucy55eXl5O1xuICB2ZWM0IHkgPSB5XyAqIG5zLnggKyBucy55eXl5O1xuICB2ZWM0IGggPSAxLjAgLSBhYnMoeCkgLSBhYnMoeSk7XG4gIHZlYzQgYjAgPSB2ZWM0KHgueHksIHkueHkpO1xuICB2ZWM0IGIxID0gdmVjNCh4Lnp3LCB5Lnp3KTtcbiAgdmVjNCBzMCA9IGZsb29yKGIwKSoyLjAgKyAxLjA7XG4gIHZlYzQgczEgPSBmbG9vcihiMSkqMi4wICsgMS4wO1xuICB2ZWM0IHNoID0gLXN0ZXAoaCwgdmVjNCgwLjApKTtcbiAgdmVjNCBhMCA9IGIwLnh6eXcgKyBzMC54enl3KnNoLnh4eXk7XG4gIHZlYzQgYTEgPSBiMS54enl3ICsgczEueHp5dypzaC56end3O1xuICB2ZWMzIHAwID0gdmVjMyhhMC54eSxoLngpO1xuICB2ZWMzIHAxID0gdmVjMyhhMC56dyxoLnkpO1xuICB2ZWMzIHAyID0gdmVjMyhhMS54eSxoLnopO1xuICB2ZWMzIHAzID0gdmVjMyhhMS56dyxoLncpO1xuXG4gIC8vIE5vcm1hbGlzZSBncmFkaWVudHNcbiAgdmVjNCBub3JtID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChwMCxwMCksIGRvdChwMSxwMSksIGRvdChwMiwgcDIpLCBkb3QocDMscDMpKSk7XG4gIHAwICo9IG5vcm0ueDtcbiAgcDEgKj0gbm9ybS55O1xuICBwMiAqPSBub3JtLno7XG4gIHAzICo9IG5vcm0udztcblxuICAvLyBNaXggZmluYWwgbm9pc2UgdmFsdWVcbiAgdmVjNCBtID0gbWF4KDAuNiAtIHZlYzQoZG90KHgwLHgwKSwgZG90KHgxLHgxKSwgZG90KHgyLHgyKSwgZG90KHgzLHgzKSksIDAuMCk7XG4gIG0gPSBtICogbTtcbiAgcmV0dXJuIDQyLjAgKiBkb3QobSptLCB2ZWM0KGRvdChwMCx4MCksIGRvdChwMSx4MSksIGRvdChwMix4MiksIGRvdChwMyx4MykpKTtcbn1cblxudm9pZCBtYWluKCkge1xuICB2ZWMyIG5vaXNlQ29vcmQgPSB1diAqIHZlYzIoNi4sIDguKTsgLy8gSW5jcmVhc2VkIGZyZXF1ZW5jeVxuICBmbG9hdCB0aWx0ID0gLTEuMiAqIHV2Lnk7IC8vIEluY3JlYXNlZCB0aWx0XG4gIGZsb2F0IGluY2xpbmUgPSB1di54ICogMC4yOyAvLyBJbmNyZWFzZWQgaW5jbGluZVxuICBmbG9hdCBvZmZzZXQgPSBpbmNsaW5lICogbWl4KC0wLjUsIDAuNSwgdXYueSk7IC8vIEluY3JlYXNlZCBvZmZzZXRcbiAgXG4gIGZsb2F0IG5vaXNlID0gc25vaXNlKHZlYzMobm9pc2VDb29yZC54ICsgdGltZSAqIDYuLCBub2lzZUNvb3JkLnksIHRpbWUgKiAyMC4pKTsgLy8gSW5jcmVhc2VkIG5vaXNlIHNwZWVkXG4gIG5vaXNlID0gbWF4KDAuLCBub2lzZSk7XG4gIFxuICB2ZWMzIHBvcyA9IHZlYzMoXG4gICAgcG9zaXRpb24ueCxcbiAgICBwb3NpdGlvbi55LFxuICAgIHBvc2l0aW9uLnogKyBub2lzZSAqIDAuNiArIHRpbHQgKyBpbmNsaW5lICsgb2Zmc2V0IC8vIEluY3JlYXNlZCBub2lzZSBpbXBhY3RcbiAgKTtcblxuICB2Q29sb3IgPSB1Q29sb3JbNF07XG4gIFxuICBmb3IoaW50IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgZmxvYXQgbm9pc2VGbG93ID0gMTAuICsgZmxvYXQoaSkgKiAwLjY7IC8vIEluY3JlYXNlZCBub2lzZSBmbG93XG4gICAgZmxvYXQgbm9pc2VTcGVlZCA9IDIwLiArIGZsb2F0KGkpICogMC42OyAvLyBJbmNyZWFzZWQgbm9pc2Ugc3BlZWRcbiAgICBmbG9hdCBub2lzZVNlZWQgPSAyLiArIGZsb2F0KGkpICogMjAuMDsgLy8gSW5jcmVhc2VkIG5vaXNlIHNlZWRcbiAgICB2ZWMyIG5vaXNlRnJlcSA9IHZlYzIoMi4sIDIuOCkgKiAwLjI7IC8vIEluY3JlYXNlZCBub2lzZSBmcmVxdWVuY3lcbiAgICBmbG9hdCBub2lzZUZsb29yID0gMC4yOyAvLyBBZGp1c3RlZCBub2lzZSBmbG9vclxuICAgIGZsb2F0IG5vaXNlQ2VpbCA9IDAuOCArIGZsb2F0KGkpICogMC4xNDsgLy8gSW5jcmVhc2VkIG5vaXNlIGNlaWxpbmdcbiAgICBcbiAgICBmbG9hdCBub2lzZSA9IHNtb290aHN0ZXAoXG4gICAgICBub2lzZUZsb29yLFxuICAgICAgbm9pc2VDZWlsLFxuICAgICAgc25vaXNlKHZlYzMoXG4gICAgICAgIG5vaXNlQ29vcmQueCAqIG5vaXNlRnJlcS54ICsgdGltZSAqIG5vaXNlRmxvdyxcbiAgICAgICAgbm9pc2VDb29yZC55ICogbm9pc2VGcmVxLnksIFxuICAgICAgICB0aW1lICogbm9pc2VTcGVlZCArIG5vaXNlU2VlZFxuICAgICAgKSlcbiAgICApO1xuICAgIFxuICAgIHZDb2xvciA9IG1peCh2Q29sb3IsIHVDb2xvcltpXSwgbm9pc2UpO1xuICB9XG5cbiAgdlV2ID0gdXY7XG4gIHZQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvcywgMS4wKTtcbn1cbmBcblxuZXhwb3J0IGNvbnN0IGZyYWdtZW50U2hhZGVyID0gYFxudW5pZm9ybSBmbG9hdCB0aW1lO1xudW5pZm9ybSBmbG9hdCBwcm9ncmVzcztcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmUxO1xudW5pZm9ybSB2ZWM0IHJlc29sdXRpb247XG52YXJ5aW5nIHZlYzIgdlV2O1xudmFyeWluZyB2ZWMzIHZQb3NpdGlvbjtcbnZhcnlpbmcgdmVjMyB2Q29sb3I7XG5mbG9hdCBQSSA9IDMuMTQxNTkyNjUzNTg5NzkzMjM4O1xuXG52b2lkIG1haW4oKSB7XG4gIC8vIHZlYzIgbmV3VVYgPSAodlV2IC0gdmVjMigwLjUpKSpyZXNvbHV0aW9uLnp3ICsgdmVjMigwLjUpO1xuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZDb2xvciwgMS4pO1xufVxuYCJdLCJuYW1lcyI6WyJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/shaders/shaders.ts\n"));

/***/ })

});